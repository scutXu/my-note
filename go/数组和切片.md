数组的声明

```
var a [10]int
b := [2] string {
    "hello",
    "world"
}
var c [3]int = [3]int{1, 2, 3}
d := [...]int{1, 2, 3}
```

对于数组而言，长度属于类型的一部分

```
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} //compile error
```

两个数组可比较的条件是：1）数组元素类型和数组长度相同，2）数组元素类型是可比较的。相等的条件是每个对应的元素都相等

```
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
d := [3]int{1, 2}
fmt.Println(a == b, a == c, a == d) //"true false false"
```

和其他大部分语言不同，当数组作为函数参数时，会拷贝传值，这意味着性能损耗且函数无法对数组的内容进行修改。为了解决这个问题，参数类型可以是数组的指针。但这并不是最灵活的解决方案，因为此函数只能接收固定个数数组的指针类型

```
//此函数不能接受*[16]byte类型的指针
func zero(ptr *[32]byte) {
	*ptr = [32]byte{}
}
```

切片和数组的声明区别在于[ ]中是否带数字

```
var a [10] int

s0 := a[0:3]
var s1 [] int = a[3:10]
```

切片只是数组的引用，修改一方的数据会影响另一方的值。以下代码相当于创建一个数组并基于数据创建切片

```
s := [] bool {
    true,
    true,
    false
}
```

切片／数组的长度和容量

```
var a [10]int
s := a[0:5]

lenA = len(a)       //10
capA = cap(a)       //10    

lenS = len(s)       //5
capS = cap(s)       //10
```

动态创建切片

```
a := make([]int, 5)     //len(a) = 5, cap(a) = 5
b := make([]int, 0, 5)  //len(b) = 0, cap(b) = 5
```

往切片追加数据,会影响所引用的数组的内容

```

```
当切片的容量不足以存储所有的数据时，go会重新申请一个新的数组。此时append返回的新切片和原数组的关联关系会被切断。

```

```

结构体数组／切片

```
//Vertex是预定义的结构体
a := [] Vertex {
	{0, 1},
	{1, 2},    //,避免自动插入分号
}

//临时定义一个结构体
s := []struct {
	i int
	b bool
}{
	{2, true},
	{3, false},
	{5, true},
	{7, true},
	{11, false},
	{13, true},
}
```

切片和数组作为函数参数


